# 예산
## 1. 문제에 대한 이해

- **우리가 풀어야 할 문제는 무엇인가?**
  - 부서별로 신청한 금액이 들어있는 배열 d와 예산 budget이 매개변수로 주어질 때, 최대 몇 개의 부서에 물품을 지원할 수 있는지 return 하도록 solution 함수를 완성하라.
- **주어진 자료는 무엇인가?**
  - d는 부서별로 신청한 금액이 들어있는 배열이며, 길이(전체 부서의 개수)는 1 이상 100 이하입니다.
    - [1,3,2,5,4]
  - d의 각 원소는 부서별로 신청한 금액을 나타내며, 부서별 신청 금액은 1 이상 100,000 이하의 자연수입니다.
  - budget은 예산을 나타내며, 1 이상 10,000,000 이하의 자연수입니다.
  - 항상 정확히 신청한 금액만큼 지원해 줘야 하므로 남은 2원으로 나머지 부서를 지원해 주지 않습니다
    - 1원, 2원, 3원을 신청한 부서의 물품을 구매해주려면 6원이 필요합니다.
    - 1원, 2원, 5원을 신청한 부서의 물품을 구매해주려면 8원이 필요합니다.
    - 1원, 3원, 4원을 신청한 부서의 물품을 구매해주려면 8원이 필요합니다.
    - 1원, 3원, 5원을 신청한 부서의 물품을 구매해주려면 9원이 필요합니다.
- **조건은 무엇인가?**
  - 1,000원을 신청한 부서에는 정확히 1,000원을 지원해야 하며, 1,000원보다 적은 금액을 지원해 줄 수는 없습니다.
  - 최대한 많은 부서의 물품을 구매해 줄 수 있도록 하려고 합니다.
  - 신청한 금액이 들어있는 배열 d
  - 예산 budget이 매개변수

## 2. 계획 
- **전에 비슷한 문제를 알고 있는가?**
    - 최대값 문제와 비슷한 것 같다.
- **이 문제를 푸는데 있어서 유용하게 쓸 수 있는 지식은 무엇인가?**
    - 최대값 구하기
- **주어진 자료로부터 유용한 것을 이끌어 낼 수 있는가?**
    - d는 부서별로 신청한 금액이 들어있는 배열을 길이를 구해 봅니다.
    - 최대값을 구합니다.
- **계획**
    1. 작은 순서부터 배열을 정렬 해줍니다.
    2. 남은 예산의 크기가 크거나 같으면 지원하고 예산에서 제외합니다.
    3. 부서 지원할 때 1씩 증가합니다.
    4. 예산이 부족할 경우 중단합니다.

## 3. 실행

- 풀이 계획을 실행하고, 각 단계가 올바른지 점검하라.

```java
public class Solution {

    public int solution(int[] d, int budget) {
        int answer = 0;

        Arrays.sort(d);

        for (int i = 0; i < d.length; i++) {
            if (d[i] <= budget) {
                budget = budget - d[i];
                answer++;
            } else {
                break;
            }
        }

        return answer;
    }

    @Test
    void result() {
        assertThat(solution(new int[]{1, 3, 2, 5, 4}, 9)).isEqualTo(3);
        assertThat(solution(new int[]{2, 2, 3, 3}, 10)).isEqualTo(4);
    }
}
```

## 4. 반성

작은 순서부터 배열을 정렬 해줍니다. 이 조건을 제외하고 테스트를 실행 했습니다. 테스트 코드에서는 통과가 되었지만 그 다음 부터는 통과가 되지 않았습니다. 숨겨진 조건을 이해하지 못 했습니다.

- **최대한 많은 부서의 물품을 구매해 줄 수 있도록 하려고 합니다.**

이 조건을 이해하지 못 해서 `Arrays.sort()` 사용해야겠다는 생각을 못 했습니다. 최대한 많은 부서를 비교 할 수 있을려면 앞으로 배열 정렬을 고려 해봐야 겠습니다.
